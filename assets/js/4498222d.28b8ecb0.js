(self.webpackChunkdoc_ops=self.webpackChunkdoc_ops||[]).push([[2130],{3905:function(e,t,i){"use strict";i.d(t,{Zo:function(){return h},kt:function(){return m}});var a=i(7294);function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function r(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,a,n=function(e,t){if(null==e)return{};var i,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||(n[i]=e[i]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(n[i]=e[i])}return n}var d=a.createContext({}),l=function(e){var t=a.useContext(d),i=t;return e&&(i="function"==typeof e?e(t):r(r({},t),e)),i},h=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,o=e.originalType,d=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=l(i),m=n,u=p["".concat(d,".").concat(m)]||p[m]||c[m]||o;return i?a.createElement(u,r(r({ref:t},h),{},{components:i})):a.createElement(u,r({ref:t},h))}));function m(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=i.length,r=new Array(o);r[0]=p;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:n,r[1]=s;for(var l=2;l<o;l++)r[l]=i[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,i)}p.displayName="MDXCreateElement"},1496:function(e,t,i){"use strict";i.r(t),i.d(t,{frontMatter:function(){return s},contentTitle:function(){return d},metadata:function(){return l},toc:function(){return h},default:function(){return p}});var a=i(2122),n=i(9756),o=(i(7294),i(3905)),r=["components"],s={title:"IOTA DID Method Specification",sidebar_label:"DID Method",description:"How IOTA Identity implements the Decentralized Identifiers Standard on the IOTA Tangle.",image:"/img/Identity_icon.png",keywords:["DID","specs","specifications","Decentralized Identifiers","Tangle","format"]},d="IOTA DID Method Specification",l={unversionedId:"specs/iota_did_method_spec",id:"specs/iota_did_method_spec",isDocsHomePage:!1,title:"IOTA DID Method Specification",description:"How IOTA Identity implements the Decentralized Identifiers Standard on the IOTA Tangle.",source:"@site/docs/specs/iota_did_method_spec.md",sourceDirName:"specs",slug:"/specs/iota_did_method_spec",permalink:"/docs/specs/iota_did_method_spec",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/documentation/docs/specs/iota_did_method_spec.md",tags:[],version:"current",frontMatter:{title:"IOTA DID Method Specification",sidebar_label:"DID Method",description:"How IOTA Identity implements the Decentralized Identifiers Standard on the IOTA Tangle.",image:"/img/Identity_icon.png",keywords:["DID","specs","specifications","Decentralized Identifiers","Tangle","format"]},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/specs/overview"},next:{title:"Merkle Key Collection",permalink:"/docs/specs/merkle_key_collection"}},h=[{value:"Abstract",id:"abstract",children:[]},{value:"Introduction",id:"introduction",children:[{value:"The IOTA Tangle",id:"the-iota-tangle",children:[]}]},{value:"DID Method Name",id:"did-method-name",children:[]},{value:"DID Format",id:"did-format",children:[{value:"IOTA-Network",id:"iota-network",children:[]},{value:"IOTA-Tag",id:"iota-tag",children:[]}]},{value:"DID Messages",id:"did-messages",children:[{value:"Previous Message Id",id:"previous-message-id",children:[]},{value:"Signing Key",id:"signing-key",children:[]},{value:"Autonomy of DID Integration Messages",id:"autonomy-of-did-integration-messages",children:[]},{value:"Autonomy of the Diff DID Messages",id:"autonomy-of-the-diff-did-messages",children:[]},{value:"Autonomy of the Proof object",id:"autonomy-of-the-proof-object",children:[]},{value:"Autonomy of the Diff object",id:"autonomy-of-the-diff-object",children:[]}]},{value:"CRUD Operations",id:"crud-operations",children:[{value:"Create",id:"create",children:[]},{value:"Read",id:"read",children:[]},{value:"Update",id:"update",children:[]},{value:"Delete",id:"delete",children:[]}]},{value:"IOTA Identity standards",id:"iota-identity-standards",children:[{value:"Standardized Verification Method Types",id:"standardized-verification-method-types",children:[]},{value:"Revocation",id:"revocation",children:[]},{value:"Standardized Services",id:"standardized-services",children:[]}]},{value:"Security Considerations",id:"security-considerations",children:[{value:"Stateless Identities",id:"stateless-identities",children:[]},{value:"Snapshotting",id:"snapshotting",children:[]},{value:"Denial of Service Attacks",id:"denial-of-service-attacks",children:[]},{value:"Quantum Computer Threats",id:"quantum-computer-threats",children:[]},{value:"Private Key Management",id:"private-key-management",children:[]}]},{value:"Privacy Considerations",id:"privacy-considerations",children:[{value:"Personal Identifiable Information",id:"personal-identifiable-information",children:[]},{value:"Correlation Risks",id:"correlation-risks",children:[]}]}],c={toc:h};function p(e){var t=e.components,s=(0,n.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"iota-did-method-specification"},"IOTA DID Method Specification"),(0,o.kt)("p",null,"Version 0.2-draft by Jelle Millenaar, IOTA Foundation"),(0,o.kt)("h2",{id:"abstract"},"Abstract"),(0,o.kt)("p",null,"The IOTA DID Method Specification describes a method of implementing the ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/did-core/"},"Decentralized Identifiers")," (DID) standard on the ",(0,o.kt)("a",{parentName:"p",href:"https://iota.org"},"IOTA Tangle"),", a Distributed Ledger Technology (DLT). It conforms to the ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/2020/WD-did-core-20200731/"},"DID specifications v1.0 Working Draft 20200731")," and describes how to publish DID Document Create, Read, Update and Delete (CRUD) operations to the IOTA Tangle. In addition, it lists additional non-standardized features that are built for the IOTA Identity implementation. "),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("h3",{id:"the-iota-tangle"},"The IOTA Tangle"),(0,o.kt)("p",null,"This specification defines a method of implementing DID on top of the ",(0,o.kt)("a",{parentName:"p",href:"https://iota.org"},"IOTA Tangle"),", which is a Distributed Ledger Technology (DLT) using a Tangle data structure. In contrast to a Blockchain, the Tangle does not store messages in blocks and chain them together, but rather creates a data structure where a message references between one and eight previous messages (used to be two, as the gif shows), creating a parallel structure. "),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"Blockchain"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Tangle")))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Blockchain bottleneck",src:i(4625).Z})," | ",(0,o.kt)("img",{alt:"Tangle Bottleneck",src:i(8939).Z})),(0,o.kt)("p",null,"For this method, the most important features of IOTA are: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The lack of fees, requiring no cryptocurrency tokens to be owned in order to submit a message to the DLT."),(0,o.kt)("li",{parentName:"ul"},"The DLT has a public and permissionless network which runs the IOTA cryptocurrency."),(0,o.kt)("li",{parentName:"ul"},"Pure data messages are possible to be stored immutably. "),(0,o.kt)("li",{parentName:"ul"},"Few nodes store the entire Tangle, requiring additional logic to prove the immutability of data. ")),(0,o.kt)("h2",{id:"did-method-name"},"DID Method Name"),(0,o.kt)("p",null,"The namestring to identify this DID method is: ",(0,o.kt)("inlineCode",{parentName:"p"},"iota"),"."),(0,o.kt)("p",null,"A DID that uses this method MUST begin with the following prefix: ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota"),". Following the generic DID specification, this string MUST be completely in lowercase."),(0,o.kt)("h2",{id:"did-format"},"DID Format"),(0,o.kt)("p",null,"The DIDs that follow this method have the following format:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'iota-did = "did:iota:" iota-specific-idstring\niota-specific-idstring = [ iota-network ":" ] [ network-shard ":" ] iota-tag\niota-network = char{,6}\niota-tag = base-char{44}\nchar = 0-9 a-z\nbase-char = 1-9 A-H J-N P-Z a-k m-z\n')),(0,o.kt)("h3",{id:"iota-network"},"IOTA-Network"),(0,o.kt)("p",null,"The iota-network is an identifer of the network where the DID is stored. This network must be an IOTA Tangle, but can either be a public or private network, permissionless or permissioned."),(0,o.kt)("p",null,"The following values are reserved and cannot reference other networks:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"main")," references the main network which refers to the Tangle known to host the IOTA cryptocurrency"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"test"),' references the test network known as "devnet" or "testnet" maintained by the IOTA Foundation.')),(0,o.kt)("p",null,"When no IOTA network is specified, it is assumed that the DID is located on the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," network. This means that the following DIDs will resolve to the same DID Document:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"did:iota:main:H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\ndid:iota:H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\n")),(0,o.kt)("h3",{id:"iota-tag"},"IOTA-Tag"),(0,o.kt)("p",null,"The IOTA tag references an indexation which resolves to the initial DID Messages. "),(0,o.kt)("h4",{id:"generation"},"Generation"),(0,o.kt)("p",null,"The following steps MUST be taken to generate a valid Tag:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Generate an asymmetric keypair using a supported verification method type."),(0,o.kt)("li",{parentName:"ul"},"Hash the public key using ",(0,o.kt)("inlineCode",{parentName:"li"},"BLAKE2b-256")," and encode using base58.")),(0,o.kt)("p",null,"This public key MUST be embedded into the DID Document (See ",(0,o.kt)("a",{parentName:"p",href:"#Create"},"CRUD: Create"),")."),(0,o.kt)("h2",{id:"did-messages"},"DID Messages"),(0,o.kt)("p",null,"DID Documents associated with the ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota"),' method consist of a chain of data messages, called "DID messages", published to a Tangle. The Tangle has no understanding of DID messages and acts purely as an immutable database. The chain of DID messages and the resulting DID Document must therefore be validated on the client side. '),(0,o.kt)("p",null,'A DID message can be part of one of two different message chains, the "Integration Chain" (Int Chain) and the "Differentiation Chain" (Diff Chain). The Integration Chain is a chain of "DID Integration Messages" that contain JSON formatted DID Documents as per the W3C standard for DID. The Diff Chain is a chain of "DID Diff Messages" that contain JSON objects which only list the differences between the previous DID Document and the next state. '),(0,o.kt)("h3",{id:"previous-message-id"},"Previous Message Id"),(0,o.kt)("p",null,"All DID message uploaded to the Tangle, with the exception of the very first DID message that creates the DID, MUST contain a ",(0,o.kt)("inlineCode",{parentName:"p"},"previousMessageId")," field. This field MUST carry the MessageId, an IOTA indexation for a single message, of the previous DID Document that is updated with this DID message. This value SHOULD be used to order DID messages during the resolving procedure. If two or more DID messages reference the same ",(0,o.kt)("inlineCode",{parentName:"p"},"previousMessageId")," an ordering conflict is identified and is resolved using a ",(0,o.kt)("a",{parentName:"p",href:"#determining-order"},"deterministic ordering mechanism"),". "),(0,o.kt)("p",null,"Example of an IOTA MessageId:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'"previousMessageId": "cd8bb7baca6bbfa1de7813bd1753a2de026b6ec75dba8a3cf32c0d4cf6038917"\n')),(0,o.kt)("h3",{id:"signing-key"},"Signing Key"),(0,o.kt)("p",null,"DID Documents published to the Tangle must be cryptographically signed. As such the DID Document MUST include one verification method with a public key. It is recommended, for security reasons, to not use this keypair for other purposes as the control over this private key is vital for controlling the identity. It is RECOMMENDED to name this public key #_sign-x, where x is the index of the signing key, which is incremented every time the signing key is updated, starting at index 1. "),(0,o.kt)("h3",{id:"autonomy-of-did-integration-messages"},"Autonomy of DID Integration Messages"),(0,o.kt)("p",null,"A DID Integration message MUST contain a valid DID Document according to the W3C DID standard. In addition, the message has further restrictions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The DID Document MUST contain one or more verification methods with a public key in the ",(0,o.kt)("inlineCode",{parentName:"li"},"verificationMethod")," property of the DID Document. It is RECOMMENDED to only use this key for updating the DID Document and name this public key #_sign-x. "),(0,o.kt)("li",{parentName:"ul"},"The first DID Document in the chain MUST contain a ",(0,o.kt)("inlineCode",{parentName:"li"},"verificationMethod")," that contains a public key that, when hashed using the ",(0,o.kt)("inlineCode",{parentName:"li"},"Blake2b-256")," hashing function, equals the tag section of the DID. This prevents the creation of conflicting entry messages of the chain by adversaries."),(0,o.kt)("li",{parentName:"ul"},"An Integration DID message must be published to an IOTA Tangle on an index that is generated by the ",(0,o.kt)("inlineCode",{parentName:"li"},"BLAKE2b-256")," of the public key, created in the ",(0,o.kt)("a",{parentName:"li",href:"#generation"},"generation")," event, encoded in ",(0,o.kt)("inlineCode",{parentName:"li"},"hex"),". "),(0,o.kt)("li",{parentName:"ul"},"DID Integration messages SHOULD contain all cumulative changes from the Diff Chain associated to the last Integration Chain message. Any changes added in the Diff Chain that are not added to the new DID Integration message will be lost. "),(0,o.kt)("li",{parentName:"ul"},"DID Integration Messages have at least the following attributes:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," (REQUIRED): This field provides an immutable link to the previous DID document that is updated and is used for basic ordering of the DID messages, creating a chain. The value of ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," MUST be a string that contains an IOTA MessageId from the previous DID message it updates, which MUST reference an Int chain message. The field SHOULD be ommited if the DID message is the start of the Int chain, otherwise the field is REQUIRED. Read the ",(0,o.kt)("a",{parentName:"li",href:"#previous-message-id"},"Previous Message Id")," section for more information. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"proof")," (REQUIRED): This field provides a cryptographic proof on the message that proves ownership over the DID Document. The value of the ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object MUST contain an object as defined by ",(0,o.kt)("a",{parentName:"li",href:"#autonomy-of-the-proof-object"},"Autonomy of the Proof object"),".")))),(0,o.kt)("p",null,"Example of a DID Integration Message:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "did:iota:GzXeqBXGCbuebiFtKo4JDNo6CmYmGbqxyh2fDVKadiBG",\n  "authentication": [\n    {\n      "id": "did:iota:GzXeqBXGCbuebiFtKo4JDNo6CmYmGbqxyh2fDVKadiBG#key-2",\n      "controller": "did:iota:GzXeqBXGCbuebiFtKo4JDNo6CmYmGbqxyh2fDVKadiBG",\n      "type": "Ed25519VerificationKey2018",\n      "publicKeyBase58": "iNhcgDu34kt4fdpZ2826qA7g8g3aqG8uLZzvWwUd9AE"\n    }\n  ],\n  "previousMessageId": "cd8bb7baca6bbfa1de7813bd1753a2de026b6ec75dba8a3cf32c0d4cf6038917",\n  "proof": {\n    "type": "JcsEd25519Signature2020",\n    "verificationMethod": "#authentication",\n    "signatureValue": "3fLtv3KUU4T5bHNLprV3UQ2Te3bcRZ9uUYSFouEA7fmYthieV35NNLqbKUu8t2QmzYgnfp1KMzCqPzGNi3RjU822"\n  }\n}\n')),(0,o.kt)("h3",{id:"autonomy-of-the-diff-did-messages"},"Autonomy of the Diff DID Messages"),(0,o.kt)("p",null,"A Diff DID message does not contain a valid DID Document. Instead, the chain creates a list of changes compared to the DID Integration message that is used as a basis. The Diff DID messages are hosted on a different index on the Tangle, which allows skipping older Diff DID messages during a query, optimizing the client verification speed significantly.  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A Diff DID message is NOT allowed to add, remove or update any keys used to sign the Diff DID messages. This must be done via an Integration DID message."),(0,o.kt)("li",{parentName:"ul"},"A Diff DID message must be published to an IOTA Tangle on an index that is generated by the hash, generated by the ",(0,o.kt)("inlineCode",{parentName:"li"},"BLAKE2b-256")," hashing algorithm, of the ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," of the latest Integration DID message and encoded in ",(0,o.kt)("inlineCode",{parentName:"li"},"hex"),". "),(0,o.kt)("li",{parentName:"ul"},"Diff DID Messages have at least the following attributes:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id")," (REQUIRED): This field helps link the update to a DID. The value of ",(0,o.kt)("inlineCode",{parentName:"li"},"id")," MUST be a string that references the DID that this update applies to. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," (REQUIRED): This field provides an immutable link to the previous DID document that is updated and is used for basic ordering of the DID messages, creating a chain. The value of ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," MUST be a string that contains an IOTA MessageId from the previous DID message it updates, which references either a Diff or Int Chain message. Read the ",(0,o.kt)("a",{parentName:"li",href:"#previous-message-id"},"Previous Message Id")," section for more information."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"diff")," (REQUIRED): A Differentiation object containing all the changes compared to the DID Document it references in the ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," field. The value of ",(0,o.kt)("inlineCode",{parentName:"li"},"diff")," MUST be an escaped JSON string following the ",(0,o.kt)("a",{parentName:"li",href:"#autonomy-of-the-diff-object"},"Autonomy of the Diff object")," definition."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"proof")," (REQUIRED): This field provides a cryptographic proof on the message that proves ownership over the DID Document. The value of the ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object MUST contain an object as defined by ",(0,o.kt)("a",{parentName:"li",href:"#autonomy-of-the-proof-object"},"Autonomy of the Proof object"),".")))),(0,o.kt)("p",null,"Example of a Diff DID message:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "did": "did:iota:7EhyBxAhFXojqzrKt8Zq7QBvxNZWJJ4xj1mm2QgLmcKj",\n  "diff": "{\\"authentication\\":[{\\"index\\":0,\\"item\\":{\\"Embed\\":{\\"id\\":\\"did:iota:7EhyBxAhFXojqzrKt8Zq7QBvxNZWJJ4xj1mm2QgLmcKj#key-3\\",\\"key_data\\":{\\"PublicKeyBase58\\":\\"TJqJAnV387wTUfzq8BVE7iJ9LYs7xJYM4SEF86LkB8E\\"}}}}],\\"properties\\":[{\\"c:k\\":\\"updated\\",\\"c:v\\":\\"2021-04-15T10:31:21Z\\"}]}",\n  "previousMessageId": "9cd2e34c049099246d247ffcf19ba0d54063add9cb7787662b5d51a2a36a8a3b",\n  "proof": {\n    "type": "JcsEd25519Signature2020",\n    "verificationMethod": "#key-2",\n    "signatureValue": "G4otnurZMiXwKYpFxZ5Nk99R95FZQ2YSYjztDosaXbyDz8qFrzH8FHbLzFp8doUEPuyHN6CPm58QbAKUqrvq8PV"\n  }\n}\n')),(0,o.kt)("h3",{id:"autonomy-of-the-proof-object"},"Autonomy of the Proof object"),(0,o.kt)("p",null,"Following the proof format in the ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/vc-data-model/#proofs-signatures"},"Verifiable Credential standard"),", at least one proof mechanism, and the details necessary to evaluate that, MUST be expressed for a DID Document uploaded to the Tangle. "),(0,o.kt)("p",null,"The proof object is an embedded proof that contains all information to be verifiable. It contains one or more cryptographic proofs that can be used to detect tampering and verify the authorship of a DID creation or update. It mostly follows LD-Proofs standard."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Type")),(0,o.kt)("p",null,"The proof object MUST include a ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," property. This property references a verification method type's signature algorithm, as standardized in the ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/did-spec-registries/#verification-method-types"},"DID spec registries")," or standardized via the method specification. "),(0,o.kt)("p",null,"The IOTA Identity implementation currently supports:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"JcsEd25519Signature2020"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Verification Method")),(0,o.kt)("p",null,"The proof object MUST include a ",(0,o.kt)("inlineCode",{parentName:"p"},"verificationMethod")," which references a verification method embedded in the same DID Document. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Signature")),(0,o.kt)("p",null,"Depending on the verification method, a set of fields are REQUIRED to provide the cryptographic proof of the DID Document. For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"JcsEd25519Signature2020")," method has a ",(0,o.kt)("inlineCode",{parentName:"p"},"signatureValue")," field. "),(0,o.kt)("p",null,"Example ",(0,o.kt)("inlineCode",{parentName:"p"},"proof")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},"JcsEd25519Signature2020")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'"proof": {\n    "type": "JcsEd25519Signature2020",\n    "verificationMethod": "did:iota:GzXeqBXGCbuebiFtKo4JDNo6CmYmGbqxyh2fDVKadiBG#authentication",\n    "signatureValue": "3fLtv3KUU4T5bHNLprV3UQ2Te3bcRZ9uUYSFouEA7fmYthieV35NNLqbKUu8t2QmzYgnfp1KMzCqPzGNi3RjU822"\n}\n')),(0,o.kt)("h3",{id:"autonomy-of-the-diff-object"},"Autonomy of the Diff object"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"diff")," object MUST contain all the differences between the previous DID Document and the current DID Document. The differentiation is formatted as an escaped JSON object, that includes the differences between the two DID Document objects. Exact details of how this is generated will be added later. "),(0,o.kt)("p",null,"Example ",(0,o.kt)("inlineCode",{parentName:"p"},"diff")," of adding an ",(0,o.kt)("inlineCode",{parentName:"p"},"authentication")," key and changing the ",(0,o.kt)("inlineCode",{parentName:"p"},"updated")," field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "diff": "{\\"authentication\\":[{\\"index\\":0,\\"item\\":{\\"Embed\\":{\\"id\\":\\"did:iota:7EhyBxAhFXojqzrKt8Zq7QBvxNZWJJ4xj1mm2QgLmcKj#key-3\\",\\"key_data\\":{\\"PublicKeyBase58\\":\\"TJqJAnV387wTUfzq8BVE7iJ9LYs7xJYM4SEF86LkB8E\\"}}}}],\\"properties\\":[{\\"c:k\\":\\"updated\\",\\"c:v\\":\\"2021-04-15T10:31:21Z\\"}]}"\n} \n')),(0,o.kt)("h2",{id:"crud-operations"},"CRUD Operations"),(0,o.kt)("p",null,"Create, Read, Update and Delete (CRUD) operations that change the DID Documents are to be submitted to an IOTA Tangle in order to be publicly avaliable. They will either have to be a valid Int DID message or Diff DID message, submitted on the correct index of the identity. "),(0,o.kt)("h3",{id:"create"},"Create"),(0,o.kt)("p",null,"To generate a new DID, the method described in ",(0,o.kt)("a",{parentName:"p",href:"#generation"},"generation")," must be followed. A basic DID Document must be created that includes the public key used in the DID creation process as a ",(0,o.kt)("inlineCode",{parentName:"p"},"verificationMethod"),". This DID Document must be formatted as an Integration DID message and published to an IOTA Tangle on the index generated out of the public key used in the DID creation process. "),(0,o.kt)("h3",{id:"read"},"Read"),(0,o.kt)("p",null,"To read the latest DID Document associated with a DID, the following steps are to be performed:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Query all the Integration DID messages from the index, which is the ",(0,o.kt)("inlineCode",{parentName:"li"},"tag")," part of the DID."),(0,o.kt)("li",{parentName:"ol"},"Order the messages based on ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," linkages. See ",(0,o.kt)("a",{parentName:"li",href:"#determining-order"},"Determining Order")," for more details."),(0,o.kt)("li",{parentName:"ol"},"Validate the first Integration DID message that contains a public key inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"verificationMethod")," field that, when hashed using the ",(0,o.kt)("inlineCode",{parentName:"li"},"BLAKE2b-256")," hashing algorithm, equals the ",(0,o.kt)("inlineCode",{parentName:"li"},"tag")," field of the DID. "),(0,o.kt)("li",{parentName:"ol"},"Verify the signatures of all the DID messages. Signatures must be created using a public key avaliable in the previous DID message. "),(0,o.kt)("li",{parentName:"ol"},"Ignore any messages that are not signed correctly, afterwards ignore any messages that are not first in the ordering for their specific location in the chain."),(0,o.kt)("li",{parentName:"ol"},"If a URL parameter is added to the Resolution of ",(0,o.kt)("inlineCode",{parentName:"li"},"diff=false"),", the following steps can be skipped and you should now have the latest DID Document."),(0,o.kt)("li",{parentName:"ol"},"Query all the Differentiation DID messages from the index, generated by the MessageId from the last valid Integration DID message, hashed using ",(0,o.kt)("inlineCode",{parentName:"li"},"Blake2b-256")," and encoded in ",(0,o.kt)("inlineCode",{parentName:"li"},"hex"),"."),(0,o.kt)("li",{parentName:"ol"},"Order and validate signatures in a similar manner to steps 2,4 and 5 above."),(0,o.kt)("li",{parentName:"ol"},"Ignore messages with illegal operations such as removing or updating a signing key."),(0,o.kt)("li",{parentName:"ol"},"Apply all valid Differentation updates to the state generated from the Integration DID messages. This will provide you the latest DID Document.")),(0,o.kt)("h4",{id:"determining-order"},"Determining Order"),(0,o.kt)("p",null,"To determine order of any DID messages, the following steps are to be performed:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Order is initially established by recreating the chain based on the ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," linkages. "),(0,o.kt)("li",{parentName:"ol"},"When two or more Messages compete, an order must be established between them."),(0,o.kt)("li",{parentName:"ol"},"To determine the order, check which milestone confirmed the messages."),(0,o.kt)("li",{parentName:"ol"},"If multiple messages are confirmed by the same milestone, we order based on the IOTA MessageId with alphabetical ordering.")),(0,o.kt)("h3",{id:"update"},"Update"),(0,o.kt)("p",null,"In order to update a DID Document, either an Integration or a Differentation DID message needs to be generated. It is RECOMMENDED to use only Integration DID messages if the DID Document is updated very infrequently and it is expected to never go beyond 100 updates in the lifetime of the DID. If that is not the case, it is RECOMMENDED to use as many Differentiation DID messages instead with a maximum of around 100 updates per Diff chain. "),(0,o.kt)("h4",{id:"creating-an-integration-did-message"},"Creating an Integration DID message"),(0,o.kt)("p",null,"An Integration DID message is unrestricted in its operations and may add or remove any fields to the DID Document. In order to query the DID Document, every Integration DID message must be processed, therefore it is RECOMMENDED to reduce the usage of these messages unless the DID Document is updated very infrequently. "),(0,o.kt)("p",null,"In order to create a valid Integration DID message, the following steps are to be performed:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a new DID Document that contains all the new target state. This SHOULD include the new desired changes and all the changes inside the previous Diff Chain, otherwise these changes are lost!"),(0,o.kt)("li",{parentName:"ol"},"Retrieve the IOTA MessageId from the previous Integration DID message and a keypair for signing the DID Document."),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," field to the IOTA MessageId value."),(0,o.kt)("li",{parentName:"ol"},"Create a ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object referencing the public key used inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"verificationMethod")," field and the signature suite in the ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," field. "),(0,o.kt)("li",{parentName:"ol"},"Create a cryptographic signature using the same keypair and add the result to the appropriate field(s) inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object.")),(0,o.kt)("h4",{id:"creating-a-differentiation-did-message"},"Creating a Differentiation DID message"),(0,o.kt)("p",null,"A Differentiation DID message is restricted in its usage. It may not update any signing keys that are used in the Diff chain. If this is desired, it is REQUIRED to use an Integretation DID message. If the current Diff chain becomes too long (currently RECOMMENDED to end at a length of 100), it is RECOMMENDED to use a single Integration DID message to reset its length."),(0,o.kt)("p",null,"In order to create a valid Integration DID message, the following steps are to be performed:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create and serialize a ",(0,o.kt)("inlineCode",{parentName:"li"},"diff")," JSON object that contains all the changes. "),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("inlineCode",{parentName:"li"},"did")," field to the DID value that this update applies to."),(0,o.kt)("li",{parentName:"ol"},"Retrieve the IOTA MessageId from the previous Diff chain message, or Integration DID message if this message is the first in the Diff chain. In addition, retrieve a keypair for signing the DID Document."),(0,o.kt)("li",{parentName:"ol"},"Set the ",(0,o.kt)("inlineCode",{parentName:"li"},"previousMessageId")," field to the IOTA MessageId value."),(0,o.kt)("li",{parentName:"ol"},"Create a ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object referencing the public key used inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"verificationMethod")," field and the signature suite in the ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," field. "),(0,o.kt)("li",{parentName:"ol"},"Create a cryptographic signature using the same keypair and add the result to the appropriate field(s) inside the ",(0,o.kt)("inlineCode",{parentName:"li"},"proof")," object.")),(0,o.kt)("h3",{id:"delete"},"Delete"),(0,o.kt)("p",null,"In order to deactivate a DID document, a valid Integration DID message must be published that removes all content from a DID Document, effectively deactivating the DID Document. Keep in mind that this is irreversible."),(0,o.kt)("h2",{id:"iota-identity-standards"},"IOTA Identity standards"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method is implemented in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/identity.rs"},"IOTA Identity framework"),". This framework supports a number of operations that are standardized, some are standardized across the SSI community, and some are the invention of the IOTA Foundation. "),(0,o.kt)("h3",{id:"standardized-verification-method-types"},"Standardized Verification Method Types"),(0,o.kt)("p",null,"We support two different Verification Method Types. Verification methods that can be used for signing DID Documents, and verification methods that are only used for signing ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/vc-data-model/"},"W3C standardized Verifiable Credentials"),". This set differs as the IOTA Identity implements revocation of Verifiable Credentials through public key removal, which requires every credential to be signed by a different keypair. We create collection of keypairs in a Merkle Tree in order to save space in the DID Document."),(0,o.kt)("p",null,"Verification Methods that can be used to sign DID Documents and do other repeatable activities:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Ed25519VerificationKey2018")," to create a ",(0,o.kt)("inlineCode",{parentName:"li"},"JcsEd25519Signature2020"),".")),(0,o.kt)("p",null,"Verification Methods that can be used to sign Verifiable Credentials:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"MerkleKeyCollection2021")," to create a ",(0,o.kt)("inlineCode",{parentName:"li"},"MerkleKeySignature2021"),".")),(0,o.kt)("h3",{id:"revocation"},"Revocation"),(0,o.kt)("p",null,"As mentioned above, revocation of Verifiable Credentials is done through revoking public keys in the IOTA Identity framework. IOTA Identity has a highly scalable solution since some identities might sign and want to revoke thousands if not millions of Verifiable Credentials. It is also GDPR compliant, leaving no trace, not even a hash, of a verifiable credential on the Tangle. Below will be a brief overview of how this mechanism works, but you may read all the details in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/specs/merkle_key_collection"},"MerkleKeyCollection standardization document"),". "),(0,o.kt)("h4",{id:"key-collections"},"Key Collections"),(0,o.kt)("p",null,"Instead of storing individual public keys in a DID Document, IOTA Identity introduces the ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleKeyCollection2021")," verification method. It supports a REQUIRED ",(0,o.kt)("inlineCode",{parentName:"p"},"publicKeyBase58")," field that MUST contain the top hash of a Merkle Tree. In this Merkle Tree all the individual leaves are public keys using the signature algorithm of choice and digest algorithm of choice for the Merkle Tree process. This process allows the creation of millions of public keys within a single verification method and without bloating the DID Document. Specific info such as the maximum depth of the Merkle Tree, supported signature algorithms and digest algorithms can be found ",(0,o.kt)("a",{parentName:"p",href:"/docs/specs/merkle_key_collection"},"in the specification document"),". "),(0,o.kt)("h4",{id:"verifiable-credential-proofs"},"Verifiable Credential Proofs"),(0,o.kt)("p",null,"In addition to the normal signature, a ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleKeySignature2021")," requires additional proof data to validate the signature's origin and validity. The public key itself needs to be revealed inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"signatureValue")," field, but also the individual hashes inside the Merkle Tree and their relative location in the path to create a valid ",(0,o.kt)("inlineCode",{parentName:"p"},"Proof of Inclusion"),". "),(0,o.kt)("h4",{id:"revocation-list"},"Revocation List"),(0,o.kt)("p",null,"In order to revoke a public key, and therefore any Verifiable Credential or other statements, the DID Document must be updated with a revocation list. The REQUIRED ",(0,o.kt)("inlineCode",{parentName:"p"},"revocation")," field is introduced inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleKeyCollection2021")," verification method, which lists the indices from the leaves of the Merkle Tree that are revoked. These indices are further compressed via ",(0,o.kt)("a",{parentName:"p",href:"https://roaringbitmap.org/"},"Roaring Bitmaps"),"."),(0,o.kt)("h3",{id:"standardized-services"},"Standardized Services"),(0,o.kt)("p",null,"The IOTA Identity framework also standardized certain ",(0,o.kt)("inlineCode",{parentName:"p"},"services")," that are embedded in the DID Document. It is RECOMMENDED to implement these when implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method. "),(0,o.kt)("p",null,"Currently standardized ",(0,o.kt)("inlineCode",{parentName:"p"},"services"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Nothing yet. ")),(0,o.kt)("h2",{id:"security-considerations"},"Security Considerations"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method is implemented on the ",(0,o.kt)("a",{parentName:"p",href:"https://iota.org"},"IOTA Tangle"),", a public permissionless and feeless Distributed Ledger Technology (DLT), making it resistant against almost all censorship attack vectors. Up until the ",(0,o.kt)("inlineCode",{parentName:"p"},"Coordicide")," update for the IOTA network, a reliability on the coordinator exists for resolving ordering conflicts. This has a minor censorship possibility, that, in the worst case, can prevent ordering conflicts from resolving to a DID. However, these can only be published by the owner of the private key and therefore does not constitute a usable attack vector. Lastly, a node may decide to censor DID messages locally, however a user can easily use another node. "),(0,o.kt)("p",null,"Since DID messages are always to be signed and the 'chain of custody' of the signing key can be traced throughout the identity lifespan, replay, message insertion, deletion, modification and man-in-the-middle attacks are prevented."),(0,o.kt)("h3",{id:"stateless-identities"},"Stateless Identities"),(0,o.kt)("p",null,"Unlike for-purpose blockchains or Smart Contract based DID methods, the IOTA Tangle does not track and store the state of DID Document. This prevents dusting attacks against the nodes. However, the client that resolves the DID Document has the responsibility to always validate the entire history of the DID Document as to validate the 'chain of custody' of the signing keys. If a client does not do this, identity hijacking is trivially possible. The IOTA Identity framework, which implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method, provides an easy-to-use client-side validation implementation. "),(0,o.kt)("h3",{id:"snapshotting"},"Snapshotting"),(0,o.kt)("p",null,"IOTA allows feeless data and value messages. As such, it has a large history of messages amounting to several TBs at the time of writing. Most nodes 'snapshot' (forget/delete) older transactions, while they keep the UTXOs stored in the ledger. The snapshot settings are local, therefore all nodes may store a different length of history. As such, older DID messages would not be avaliable at every node. Since the entire history of the DID Document is required for client-side validation, this may become problematic. It is currently recommended to either use your own node that does not snapshot, or use the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/chronicle.rs"},"Chronicle Permanode"),", which keeps the entire history of the Tangle. This is not a longterm scalable solution, which is why other methods for either keeping state or selective storage are considered. "),(0,o.kt)("h3",{id:"denial-of-service-attacks"},"Denial of Service Attacks"),(0,o.kt)("p",null,"There is little to no barrier for users to send any message to the Tangle. While this is a great feature of IOTA, it has its drawbacks in terms of spam. Anyone can post messages on the index of an Identity and therefore decrease the query speed. To reduce a user's own load on their identity verification speed, the Diff chain was introduced. Other messages that are spammed are identified and dropped as early as possible in the resolution process without triggering any errors or warnings. These are, for example, random data messages or incorrectly signed DID messages. "),(0,o.kt)("p",null,"IOTA nodes provide pagination for more then 100 messages on an index, requiring multiple queries for identities with more messages. Since the queries are the bottleneck in the resolution process, it is recommended to run an IOTA node in a nearby location if fast verification is required for the use case. Verification may, in the future, also be outsourced to nodes directly, to reduce the effect of spam attacks. If an identity is significantly spammed, it might be best to create a new identity. "),(0,o.kt)("h3",{id:"quantum-computer-threats"},"Quantum Computer Threats"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method is not more vulnerable to quantum computers than other DID methods. The IOTA Identity framework currently utilizes elliptic curve based cryptographic suites, however adding support for quantum secure cryptographic suites in the future is very easy. The ",(0,o.kt)("inlineCode",{parentName:"p"},"MerkleKeyCollection2021")," verification method is quantum secure in the sense that public keys are only revealed to the holders and verifiers of the Verifiable Credentials, keeping the exposure to this very limited. "),(0,o.kt)("h3",{id:"private-key-management"},"Private Key Management"),(0,o.kt)("p",null,"All private keys or seeds used for the ",(0,o.kt)("inlineCode",{parentName:"p"},"did:iota")," method should be equally well protected by the users. The signing key is especially important as it controls how keys are added or removed, providing full control over the identity. The IOTA Identity framework utilizes the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/stronghold.rs"},"Stronghold project"),", a secure software implementation isolating digital secrets from exposure to hacks or leaks. Developers may choose to add other ways to manage the private keys in a different manner.  "),(0,o.kt)("h2",{id:"privacy-considerations"},"Privacy Considerations"),(0,o.kt)("h3",{id:"personal-identifiable-information"},"Personal Identifiable Information"),(0,o.kt)("p",null,"The public IOTA Tangle networks are immutable networks. This means that once something is uploaded, it can never be completely removed. That directly conflicts with certain privacy laws such as GDPR, which have a 'right-to-be-forgotten' for Personal Identifiable Information (PII). As such, users should NEVER upload any PII to the Tangle, including inside DID Documents. The IOTA Identity framework allows Verifiable Credentials to be published to the Tangle directly, however this feature should only be utilized by Identity for Organisation and Identity for Things. "),(0,o.kt)("h3",{id:"correlation-risks"},"Correlation Risks"),(0,o.kt)("p",null,"As with any DID method, identities can be linked if they are used too often and their usage somehow becomes public. IOTA provides a simple solution for this problem: as creating identities is completely feeless, it is recommended to make new identities on a per interaction basis (Pairwise DIDs). The IOTA Identity framework will provide support for this in the future."))}p.isMDXComponent=!0},4625:function(e,t,i){"use strict";t.Z=i.p+"assets/images/blockchain-bottleneck-c807d504ff52169427d3ca4cf0179a8c.gif"},8939:function(e,t,i){"use strict";t.Z=i.p+"assets/images/tangle-bottleneck-ad9ab01d5399a5cefbac1cbd1be3900a.gif"}}]);